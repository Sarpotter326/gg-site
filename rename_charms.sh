#!/usr/bin/env bash
# rename_charms.sh
# Usage:
#   DRY_RUN=1 ./rename_charms.sh   # preview mode (does not run git mv, writes mapping-preview.json)
#   ./rename_charms.sh             # perform renames with git mv (must be on branch rename/charms-normalize)
#
# Requirements:
# - run from repository root
# - git configured and you have write access to the branch
# - jq installed (for mapping JSON updates)
# - sha1sum or shasum (script autodetects)
#
set -euo pipefail

# ===== configuration =====
FOLDER="public/Charms"
MAPPING_FILE="$FOLDER/rename-mapping.json"
MAPPING_PREVIEW="$FOLDER/rename-mapping-preview.json"
DRY_RUN="${DRY_RUN:-0}"   # set to 1 to preview instead of performing git mv
# Supported image extensions (case-insensitive)
EXTS="png jpg jpeg webp"
# =========================

# detect sha1 tool
if command -v sha1sum >/dev/null 2>&1; then
  SHA1_CMD="sha1sum"
elif command -v shasum >/dev/null 2>&1; then
  SHA1_CMD="shasum -a 1"
else
  echo "Error: no sha1sum or shasum available in PATH" >&2
  exit 1
fi

tmpfile="$(mktemp)"
echo "[]" > "$MAPPING_FILE"
echo "[]" > "$MAPPING_PREVIEW"

normalize_token() {
  local s="$1"
  # trim
  s="$(echo -n "$s" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
  # remove trailing ISO-like datestamp -YYYY-MM-DDT######.sss or -YYYY-MM-DDT###### (approx)
  s="$(echo "$s" | sed -E 's/(-[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{6}(\.[0-9]+)?)$//')"
  # remove UUID suffixes after an underscore
  s="$(echo "$s" | sed -E 's/_[0-9a-fA-F-]{36}$//')"
  # replace spaces/underscores with hyphen
  s="$(echo "$s" | sed -E 's/[[:space:]_]+/-/g')"
  # replace any sequence of non-alnum except hyphen and dot with hyphen
  s="$(echo "$s" | sed -E 's/[^a-zA-Z0-9\.-]+/-/g')"
  # lowercase
  s="$(echo "$s" | tr '[:upper:]' '[:lower:]')"
  # collapse hyphens and trim hyphens
  s="$(echo "$s" | sed -E 's/-+/-/g; s/^-+//; s/-+$//')"
  printf '%s' "$s"
}

shorthash() {
  printf '%s' "$1" | $SHA1_CMD | awk '{print substr($1,1,6)}'
}

is_image_ext() {
  local ext="$1"
  ext="${ext,,}"
  for e in $EXTS; do
    if [[ "$ext" == "$e" ]]; then
      return 0
    fi
  done
  return 1
}

declare -A seen
index_seq=1

# find files with allowed extensions (case-insensitive)
find_expr=()
for e in $EXTS; do
  find_expr+=( -iname "*.${e}" -o )
done
# remove last -o
unset 'find_expr[-1]'

while IFS= read -r -d '' file; do
  base="$(basename "$file")"
  # Skip system or invalid names
  if [[ "$base" == ".DS_Store" ]] || [[ "$base" == " .png" ]] || [[ -z "${base// /}" ]]; then
    jq --arg o "$base" --arg n "$base" '. + [{"old":$o,"new":$n,"confidence":"skipped","note":"system or invalid filename - skipped"}]' "$MAPPING_FILE" > "$tmpfile" && mv "$tmpfile" "$MAPPING_FILE"
    jq --arg o "$base" --arg n "$base" '. + [{"old":$o,"new":$n,"confidence":"skipped","note":"system or invalid filename - skipped"}]' "$MAPPING_PREVIEW" > "$tmpfile" && mv "$tmpfile" "$MAPPING_PREVIEW"
    continue
  fi

  ext="${base##*.}"
  name_noext="${base%.*}"

  if ! is_image_ext "$ext"; then
    jq --arg o "$base" --arg n "$base" '. + [{"old":$o,"new":$n,"confidence":"skipped","note":"unsupported extension - skipped"}]' "$MAPPING_FILE" > "$tmpfile" && mv "$tmpfile" "$MAPPING_FILE"
    jq --arg o "$base" --arg n "$base" '. + [{"old":$o,"new":$n,"confidence":"skipped","note":"unsupported extension - skipped"}]' "$MAPPING_PREVIEW" > "$tmpfile" && mv "$tmpfile" "$MAPPING_PREVIEW"
    continue
  fi

  # low-confidence numeric+UUID case: ^([0-9]+)_[uuid]$
  if [[ "$name_noext" =~ ^([0-9]+)_([0-9a-fA-F-]{36})$ ]]; then
    idx="${BASH_REMATCH[1]}"
    h="$(shorthash "$file")"
    target="unknown-charm-${idx}-${h}.${ext}"
    confidence="low"
    note="only numeric prefix + UUID found; autogenerated placeholder; manual review needed"
  else
    # strip trailing UUID and datestamp-like suffixes
    stripped="$(echo "$name_noext" | sed -E 's/_[0-9a-fA-F-]{36}$//; s/-[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{6}(\.[0-9]+)?$//')"

    # detect .front/.clear/.back markers and preserve them
    suffix_marker=""
    if [[ "$stripped" =~ \.(front|clear|back)$ ]]; then
      suffix_marker=".${BASH_REMATCH[1]}"
      stripped="$(echo "$stripped" | sed -E 's/\.(front|clear|back)$//')"
    fi

    normalized="$(normalize_token "$stripped")"
    if [[ "$normalized" =~ [a-z] && ${#normalized} -gt 3 ]]; then
      target="${normalized}${suffix_marker}.${ext}"
      confidence="high"
      note="normalized from descriptive tokens"
    else
      # medium: attempt product-like derivation
      if echo "$name_noext" | grep -Ei 'product|productphotos|product_photos' >/dev/null; then
        if [[ "$name_noext" =~ ([0-9]{1,6}) ]]; then
          num="${BASH_REMATCH[1]}"
          target="product-${num}.${ext}"
          confidence="medium"
          note="derived from product index in filename"
        else
          target="$(normalize_token "$name_noext").${ext}"
          confidence="medium"
          note="derived from product-like token"
        fi
      else
        # fallback placeholder
        h="$(shorthash "$file")"
        if [[ "$name_noext" =~ ^([0-9]+) ]]; then
          idx="${BASH_REMATCH[1]}"
          target="unknown-charm-${idx}-${h}.${ext}"
        else
          target="unknown-charm-${index_seq}-${h}.${ext}"
          index_seq=$((index_seq+1))
        fi
        confidence="low"
        note="opaque filename; autogenerated placeholder; manual review needed"
      fi
    fi
  fi

  # collision handling
  base_target="${target%.*}"
  if [[ -e "$FOLDER/$target" && "$FOLDER/$target" != "$file" ]] || [[ -n "${seen[$target]:-}" ]]; then
    h2="$(shorthash "$file")"
    target="${base_target}-${h2}.${ext}"
    note="${note} (collision resolved by appending hash)"
  fi

  seen["$target"]=1

  if [[ "$DRY_RUN" -eq 1 ]]; then
    echo "[DRY RUN] would rename: $base -> $target"
    jq --arg o "$base" --arg n "$target" --arg c "$confidence" --arg note "$note" '. + [{"old":$o,"new":$n,"confidence":$c,"note":$note}]' "$MAPPING_PREVIEW" > "$tmpfile" && mv "$tmpfile" "$MAPPING_PREVIEW"
  else
    # perform the rename using git mv so history is preserved
    git mv -f "$file" "$FOLDER/$target"
    jq --arg o "$base" --arg n "$target" --arg c "$confidence" --arg note "$note" '. + [{"old":$o,"new":$n,"confidence":$c,"note":$note}]' "$MAPPING_FILE" > "$tmpfile" && mv "$tmpfile" "$MAPPING_FILE"
    echo "renamed: $base -> $target (${confidence})"
  fi
done < <(find "$FOLDER" -maxdepth 1 -type f \( -iname '*.png' -o -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.webp' \) -print0)

if [[ "$DRY_RUN" -eq 1 ]]; then
  echo "DRY RUN complete. Preview mapping written to $MAPPING_PREVIEW"
else
  echo "Done. Mapping saved to $MAPPING_FILE"
fi

rm -f "$tmpfile"
